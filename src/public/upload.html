<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Upload ‚Ä¢ PicStar</title>
  <style>
    :root {
      --bg: #0b0f14;
      --panel: #111827;
      --panel-2: #0f172a;
      --txt: #e5e7eb;
      --muted: #9ca3af;
      --border: #1f2937;
      --accent: #6366f1;
      --accent-2: #22d3ee;
      --shadow: 0 10px 30px rgba(0,0,0,0.45);
    }
    * { box-sizing: border-box; }
    body {
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      margin: 0; padding: 32px 20px; min-height: 100vh;
      color: var(--txt);
      background: radial-gradient(1200px 600px at 20% -10%, rgba(34,211,238,0.08), transparent 60%),
                  radial-gradient(1000px 600px at 120% 10%, rgba(99,102,241,0.12), transparent 60%),
                  var(--bg);
    }
    .container { max-width: 1000px; margin: 0 auto; }
    a { color: var(--muted); text-decoration: none; }
    a:hover { color: #fff; }
    .card {
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 16px;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)) , var(--panel);
      box-shadow: var(--shadow);
      backdrop-filter: blur(6px);
    }
    .row { display: grid; grid-template-columns: 1fr 2fr auto; gap: .75rem; align-items: center; margin: .75rem 0; }
    label { font-weight: 600; color: #e5e7eb; }
    select, input[type="text"], input[type="number"] {
      width: 100%; padding: .65rem .8rem; border: 1px solid #334155; border-radius: 10px;
      background: var(--panel-2); color: var(--txt); outline: none; transition: border-color .15s ease;
    }
    select:focus, input:focus { border-color: var(--accent); }
    input[type="file"] { padding: .4rem 0; color-scheme: dark; }
    button, .btn {
      padding: .65rem 1rem; border-radius: 10px; border: 1px solid transparent;
      background: linear-gradient(180deg, var(--accent), #4f46e5);
      color: #fff; cursor: pointer; transition: transform .06s ease, box-shadow .15s ease, opacity .2s;
      box-shadow: 0 6px 18px rgba(99,102,241,0.35);
      display: inline-block; text-decoration: none;
    }
    button:hover { transform: translateY(-1px); box-shadow: 0 10px 24px rgba(99,102,241,0.45); }
    button.secondary { background: #0b1220; border-color: #334155; color: var(--txt); box-shadow: none; }
    button.secondary:hover { border-color: var(--accent); }
    button:disabled { opacity: .6; cursor: not-allowed; transform: none; box-shadow: none; }
    .hint { color: var(--muted); font-size: .9rem; }
    .result { margin-top: 1rem; white-space: pre-wrap; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: .95rem; color: #d1fae5; }
    .toolbar { display: flex; gap: .5rem; align-items: center; }
    .spacer { flex: 1; }
    header { margin: 0 0 1rem; display: flex; align-items: center; gap: .75rem; }
    h1, h2 { letter-spacing: .3px; }

    /* Visual editor */
    .editor-canvas { position: relative; background: #0b1220; border: 1px solid var(--border); border-radius: 12px; overflow: hidden; margin: 0 auto; }
.editor-canvas img { display: block; user-select: none; pointer-events: none; width: 100%; height: 100%; }
.overlay-box { position: absolute; border: 2px dashed #94a3b8; color: #e5e7eb; background: rgba(148,163,184,.08); border-radius: 10px; cursor: grab; display: flex; align-items: start; }
    .overlay-box:active { cursor: grabbing; }
    .overlay-box span { font-size: 12px; margin: 6px; padding: 2px 6px; border-radius: 999px; background: rgba(0,0,0,.35); }
    .overlay-box.photo { border-color: #22d3ee; background: rgba(34,211,238,.08); }
    .overlay-box.photo span { background: rgba(34,211,238,.2); }
.overlay-box.text { border-color: #f472b6; background: rgba(244,114,182,.08); }
    .overlay-box.text span { background: rgba(244,114,182,.2); }
    .overlay-box.crop { border-color: #10b981; border-width: 3px; border-style: solid; background: rgba(16,185,129,.1); }
    .overlay-box.crop span { background: rgba(16,185,129,.3); }
    .resize-handle { position: absolute; width: 14px; height: 14px; background: #10b981; border: 2px solid #fff; border-radius: 3px; cursor: nwse-resize; z-index: 10; }
    .resize-handle.br { bottom: -7px; right: -7px; }
    .resize-handle.photo-resize { background: #22d3ee; }
    .resize-handle.text-resize { background: #f472b6; }
    .crop-toggle { display: flex; align-items: center; gap: 8px; margin-top: 8px; }
    .crop-toggle input[type="checkbox"] { width: 18px; height: 18px; accent-color: #10b981; }
    .size-info { font-size: 10px; color: #9ca3af; margin-top: 2px; }
  </style>
  <script src="/public-config.js"></script>
</head>
<body>
  <div class="container">
  <a href="/">‚Üê Back</a>
  <header>
    <h1 style="margin:0">Upload Image or Video</h1>
    <span class="spacer"></span>
    <a class="btn" href="/templates.html" style="margin-right:.5rem; text-decoration:none;">maintian</a>
    <button id="refreshBtn" class="secondary">Refresh categories</button>
  </header>
  <p class="hint">Dropdowns are populated from existing templates. Use "Add new" to insert a category that doesn't exist yet.</p>

  <section class="card">
    <h2 style="margin-top:0">Categories</h2>
    <div class="row">
      <label for="mainSelect">Main category</label>
      <select id="mainSelect"></select>
      <button id="addMainBtn" type="button" class="secondary">Add new</button>
    </div>
    <div class="row">
      <label for="subSelect">Subcategory<span style="color:#b91c1c">*</span></label>
      <select id="subSelect" required></select>
      <button id="addSubBtn" type="button" class="secondary">Add new</button>
    </div>
  </section>

  <section class="card" style="margin-top:1rem;">
    <h2 style="margin-top:0">Single Upload</h2>
    <p class="hint">Automatically detects file type by MIME/extension and picks the correct API.</p>
    <form id="singleForm">
      <div class="row">
        <label for="file">File<span style="color:#b91c1c">*</span></label>
        <input id="file" name="file" type="file" accept="image/*,video/*" required />
        <span></span>
      </div>

      <div id="imageEditor" class="card" style="margin-top:.75rem; display:none;">
        <div class="hint">Drag the boxes to set positions. Drag corner handles to resize. Enable crop to select the area to keep.</div>
        <div class="hint" style="color:#22d3ee;">Photo: 60-200px (square) ‚Ä¢ <span style="color:#f472b6;">Text: min 80x40px, max 80%x60%</span></div>
        <div class="hint" style="color:#10b981;">Reference Canvas: 270x480 (9:16) ‚Äî coordinates match app pixel-to-pixel</div>
        <div class="crop-toggle">
          <input type="checkbox" id="enableCrop" />
          <label for="enableCrop" style="font-weight:600; color:#10b981;">Enable Crop (9:16 aspect ratio)</label>
          <span class="hint" style="margin-left:auto;" id="cropInfo"></span>
        </div>
        <div id="editorCanvas" class="editor-canvas" style="margin-top:.5rem;">
          <img id="previewImg" alt="preview" />
          <div id="cropBox" class="overlay-box crop" style="left:0; top:0; display:none;">
            <span>Crop Area</span>
            <div class="resize-handle br"></div>
          </div>
          <div id="photoBox" class="overlay-box photo" style="left:20px; top:20px;">
            <span>Photo</span>
            <div class="resize-handle br photo-resize"></div>
          </div>
          <div id="textBox" class="overlay-box text" style="left:180px; top:20px;">
            <span>Text</span>
            <div class="resize-handle br text-resize"></div>
          </div>
        </div>
        <div class="toolbar" style="margin-top:.5rem">
          <button type="button" id="resetBoxes" class="secondary">Reset</button>
          <span class="spacer"></span>
          <span class="hint">Photo: <span id="photoPos">(0,0)</span> <span id="photoSize"></span> ‚Ä¢ Text: <span id="textPos">(0,0)</span> <span id="textSize"></span></span>
        </div>
      </div>

      <input type="hidden" name="crop_x" id="crop_x" />
      <input type="hidden" name="crop_y" id="crop_y" />
      <input type="hidden" name="crop_w" id="crop_w" />
      <input type="hidden" name="crop_h" id="crop_h" />
      <input type="hidden" name="preview_w" id="preview_w" />
      <input type="hidden" name="preview_h" id="preview_h" />
      <input type="hidden" name="photo_w" id="photo_w" />
      <input type="hidden" name="photo_h" id="photo_h" />
      <input type="hidden" name="text_w" id="text_w" />
      <input type="hidden" name="text_h" id="text_h" />
      <input type="hidden" name="reference_w" id="reference_w" />
      <input type="hidden" name="reference_h" id="reference_h" />

      <details>
        <summary>Optional placement coordinates (images only)</summary>
        <div class="row"><label>Photo X</label><input name="photo_x" type="number" step="1" placeholder="0" /><span></span></div>
        <div class="row"><label>Photo Y</label><input name="photo_y" type="number" step="1" placeholder="0" /><span></span></div>
        <div class="row"><label>Text X</label><input name="text_x" type="number" step="1" placeholder="0" /><span></span></div>
        <div class="row"><label>Text Y</label><input name="text_y" type="number" step="1" placeholder="0" /><span></span></div>
      </details>

      <div class="toolbar" style="margin-top:.5rem">
        <button id="singleSubmit" type="submit">Upload</button>
        <span class="spacer"></span>
        <span id="decisionNote" class="hint"></span>
      </div>
    </form>
    <div id="singleOut" class="result" aria-live="polite"></div>
  </section>

  </div>
  <script>
    const mainSelect = document.getElementById('mainSelect');
    const subSelect = document.getElementById('subSelect');
    const refreshBtn = document.getElementById('refreshBtn');
    const addMainBtn = document.getElementById('addMainBtn');
    const addSubBtn = document.getElementById('addSubBtn');
    const decisionNote = document.getElementById('decisionNote');
    const API_BASE = (window.APP_CONFIG && window.APP_CONFIG.API_BASE_URL) ? window.APP_CONFIG.API_BASE_URL : '';
    const apiUrl = (p) => (API_BASE ? API_BASE.replace(/\/$/, '') + p : p);

    // Build maps: main -> set(subs), and a global set of subs
    let mapMainToSubs = new Map();
    let allMains = new Set();
    let allSubs = new Set();
    const SUB_BLOCKLIST = new Set(['banner','banners']);

    function setOptions(selectEl, values, includeEmpty=true, emptyLabel='‚Äî Select ‚Äî') {
      const value = selectEl.value;
      selectEl.innerHTML = '';
      if (includeEmpty) {
        const opt = document.createElement('option');
        opt.value = '';
        opt.textContent = emptyLabel;
        selectEl.appendChild(opt);
      }
      Array.from(values).sort().forEach(v => {
        const opt = document.createElement('option');
        opt.value = v; opt.textContent = v;
        selectEl.appendChild(opt);
      });
      // try restore previous value
      const toSelect = values.has(value) ? value : '';
      selectEl.value = toSelect;
    }

    async function fetchAllTemplatesDistinct() {
      // Paginate /api/templates to gather distinct main/sub values
      mapMainToSubs = new Map();
      allMains = new Set();
      allSubs = new Set();

      let page = 1;
      const limit = 100;
      while (true) {
        const res = await fetch(apiUrl(`/api/templates?page=${page}&limit=${limit}`));
        if (!res.ok) break;
        const json = await res.json().catch(() => ({}));
        const items = json?.data?.templates || [];
        for (const t of items) {
          const main = (t.main_category || '').trim();
          const rawSub = (t.subcategory || t.category || '').trim();
          const subLower = rawSub.toLowerCase();
          if (main) { allMains.add(main); }
          if (rawSub && !SUB_BLOCKLIST.has(subLower)) { allSubs.add(rawSub); }
          if (main && rawSub && !SUB_BLOCKLIST.has(subLower)) {
            if (!mapMainToSubs.has(main)) mapMainToSubs.set(main, new Set());
            mapMainToSubs.get(main).add(rawSub);
          }
        }
        const pages = json?.data?.pagination?.pages || page;
        if (page >= pages) break;
        page++;
      }

      // Populate selects
      setOptions(mainSelect, allMains);
      // Default subs = union; will re-filter when main changes
      setOptions(subSelect, allSubs);
    }

    // Keep the same subcategories for all mains (no filtering)
    mainSelect.addEventListener('change', () => {
      setOptions(subSelect, allSubs);
    });

    refreshBtn.addEventListener('click', (e) => { e.preventDefault(); fetchAllTemplatesDistinct().catch(console.error); });

    addMainBtn.addEventListener('click', () => {
      const name = prompt('Enter new main category name (e.g., hindu, muslim, christian):');
      if (!name) return;
      const v = name.trim().toLowerCase();
      if (!v) return;
      allMains.add(v);
      if (!mapMainToSubs.has(v)) mapMainToSubs.set(v, new Set());
      setOptions(mainSelect, allMains);
      mainSelect.value = v;
      // Subcategories are global; do not filter by main
      setOptions(subSelect, allSubs);
    });

    addSubBtn.addEventListener('click', () => {
      const main = mainSelect.value || '';
      const name = prompt('Enter new subcategory name (e.g., birthday, congratulations):');
      if (!name) return;
      const v = name.trim().toLowerCase();
      if (!v || SUB_BLOCKLIST.has(v)) return;
      allSubs.add(v);
      // Subcategories are shared across all mains
      setOptions(subSelect, allSubs);
      subSelect.value = v;
    });

    // Single upload handling
    const fileInput = document.getElementById('file');
    const singleForm = document.getElementById('singleForm');
    const singleOut = document.getElementById('singleOut');
    const singleSubmit = document.getElementById('singleSubmit');
    const editorWrap = document.getElementById('imageEditor');
    const previewImg = document.getElementById('previewImg');
    const editorCanvas = document.getElementById('editorCanvas');
    const photoBox = document.getElementById('photoBox');
    const textBox = document.getElementById('textBox');
    const photoPosEl = document.getElementById('photoPos');
    const textPosEl = document.getElementById('textPos');
    const resetBtn = document.getElementById('resetBoxes');

    const inputPhotoX = singleForm.querySelector('input[name="photo_x"]');
    const inputPhotoY = singleForm.querySelector('input[name="photo_y"]');
    const inputTextX = singleForm.querySelector('input[name="text_x"]');
    const inputTextY = singleForm.querySelector('input[name="text_y"]');
    const inputPhotoW = document.getElementById('photo_w');
    const inputPhotoH = document.getElementById('photo_h');
    const inputTextW = document.getElementById('text_w');
    const inputTextH = document.getElementById('text_h');
    const photoSizeEl = document.getElementById('photoSize');
    const textSizeEl = document.getElementById('textSize');

    // ============================================
    // FIXED REFERENCE CANVAS - FOR PIXEL-PERFECT APP MATCHING
    // ============================================
    // All coordinates are stored relative to this fixed reference canvas.
    // The app will scale these coordinates to its actual container size.
    // This ensures pixel-perfect matching between web and app.
    const REFERENCE_WIDTH = 270;   // Fixed reference width (9:16 ratio)
    const REFERENCE_HEIGHT = 480;  // Fixed reference height (9:16 ratio)

    // ============================================
    // DIMENSION CONSTANTS - MATCHING REACT NATIVE APP
    // ============================================
    // These values match exactly with the app's DraggableText.jsx and HeroScreen.jsx

    // Photo container constraints (from HeroScreen.jsx DynamicPhotoElement)
    const PHOTO_MIN_SIZE = 60;   // minSize in app
    const PHOTO_MAX_SIZE = 200;  // maxSize in app
    const PHOTO_DEFAULT_SIZE = 100; // Default photo size in app

    // Text container constraints (from DraggableText.jsx)
    const TEXT_MIN_WIDTH = 80;   // minWidth style in app
    const TEXT_MIN_HEIGHT = 40;  // minHeight style in app
    const TEXT_DEFAULT_WIDTH = 120;  // default width in app
    const TEXT_DEFAULT_HEIGHT = 50;  // default height in app
    // Max will be calculated as percentage of container (80% width, 60% height)

    // Current sizes (will be updated during resize)
    let currentPhotoSize = PHOTO_DEFAULT_SIZE;
    let currentTextWidth = TEXT_DEFAULT_WIDTH;
    let currentTextHeight = TEXT_DEFAULT_HEIGHT;

    // Crop elements
    const enableCropCheckbox = document.getElementById('enableCrop');
    const cropBox = document.getElementById('cropBox');
    const cropInfo = document.getElementById('cropInfo');
    const inputCropX = document.getElementById('crop_x');
    const inputCropY = document.getElementById('crop_y');
    const inputCropW = document.getElementById('crop_w');
    const inputCropH = document.getElementById('crop_h');
    const inputPreviewW = document.getElementById('preview_w');
    const inputPreviewH = document.getElementById('preview_h');
    let originalImageWidth = 0;
    let originalImageHeight = 0;

    function detectType(file) {
      if (!file) return { kind: 'unknown' };
      const mime = (file.type || '').toLowerCase();
      if (mime.startsWith('image/')) return { kind: 'image' };
      if (mime.startsWith('video/')) return { kind: 'video' };
      const ext = (file.name.split('.').pop() || '').toLowerCase();
      const imageExts = new Set(['jpg','jpeg','png','webp','gif','bmp','tif','tiff','svg']);
      const videoExts = new Set(['mp4','mov','m4v','webm','mkv','avi']);
      if (imageExts.has(ext)) return { kind: 'image' };
      if (videoExts.has(ext)) return { kind: 'video' };
      return { kind: 'unknown' };
    }

    function updateDecisionNote() {
      const f = fileInput.files[0];
      const t = detectType(f).kind;
      if (t === 'image') decisionNote.textContent = 'Detected image ‚Üí will POST to /api/templates/upload as field "image"';
      else if (t === 'video') decisionNote.textContent = 'Detected video ‚Üí will POST to /api/videos/upload as field "video"';
      else decisionNote.textContent = '';
    }
    fileInput.addEventListener('change', async () => {
      updateDecisionNote();
      const file = fileInput.files[0];
      if (!file) { editorWrap.style.display = 'none'; return; }
      const kind = detectType(file).kind;

      const showFromDataUrl = (dataUrl, imgW, imgH) => {
        previewImg.onload = () => {
          sizeCanvasToImage(previewImg.naturalWidth || imgW, previewImg.naturalHeight || imgH);
          centerBoxes();
          updateOutputs();
          if (enableCropCheckbox.checked) {
            initCropBox();
            updateCropOutputs();
          }
        };
        previewImg.src = dataUrl;
        editorWrap.style.display = '';
      };

      // Size canvas to FIXED REFERENCE SIZE for pixel-perfect app matching
      // The image preview is shown as background, but coordinate system is always 270x480
      function sizeCanvasToImage(imgW, imgH) {
        // ALWAYS use fixed reference canvas for consistent coordinates
        editorCanvas.style.width = REFERENCE_WIDTH + 'px';
        editorCanvas.style.height = REFERENCE_HEIGHT + 'px';

        // Store original dimensions for crop scaling
        originalImageWidth = imgW;
        originalImageHeight = imgH;

        console.log(`üìê Canvas set to fixed reference: ${REFERENCE_WIDTH}x${REFERENCE_HEIGHT} (original image: ${imgW}x${imgH})`);
      }

      if (kind === 'image') {
        const url = URL.createObjectURL(file);
        previewImg.onload = () => {
          URL.revokeObjectURL(url);
          // Size canvas to match actual image aspect ratio
          sizeCanvasToImage(previewImg.naturalWidth, previewImg.naturalHeight);
          centerBoxes();
          updateOutputs();
          if (enableCropCheckbox.checked) {
            initCropBox();
            updateCropOutputs();
          }
        };
        previewImg.src = url;
        editorWrap.style.display = '';
      } else if (kind === 'video') {
        try {
          const { dataUrl, width, height } = await generateVideoThumbnail(file);
          showFromDataUrl(dataUrl, width, height);
        } catch (e) {
          console.warn('Could not extract video frame:', e?.message || e);
          editorWrap.style.display = 'none';
        }
      } else {
        editorWrap.style.display = 'none';
      }
    });

    async function generateVideoThumbnail(file) {
      return new Promise((resolve, reject) => {
        const url = URL.createObjectURL(file);
        const video = document.createElement('video');
        video.preload = 'metadata';
        video.muted = true;
        video.src = url;
        video.onloadeddata = () => {
          const capture = () => {
            const canvas = document.createElement('canvas');
            const w = video.videoWidth || 480, h = video.videoHeight || 852;
            canvas.width = w; canvas.height = h;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(video, 0, 0, w, h);
            URL.revokeObjectURL(url);
            try {
              resolve({ dataUrl: canvas.toDataURL('image/jpeg', 0.85), width: w, height: h });
            } catch (e) { reject(e); }
          };
          // Try around 0.5s; if not seekable, fallback to 0
          video.currentTime = Math.min(0.5, (video.duration || 1) - 0.1);
          video.onseeked = capture;
          // Fallback if seeked never fires
          setTimeout(capture, 700);
        };
        video.onerror = () => { URL.revokeObjectURL(url); reject(new Error('Failed to load video for thumbnail')); };
      });
    }

    function centerBoxes() {
      // ============================================
      // USE FIXED REFERENCE CANVAS FOR PIXEL-PERFECT APP MATCHING
      // ============================================
      // All coordinates are relative to REFERENCE_WIDTH x REFERENCE_HEIGHT (270x480)
      const W = REFERENCE_WIDTH;
      const H = REFERENCE_HEIGHT;

      // Photo: Use app's default size (100px), constrained by min/max
      let photoSize = PHOTO_DEFAULT_SIZE;
      photoSize = Math.max(PHOTO_MIN_SIZE, Math.min(PHOTO_MAX_SIZE, photoSize));

      // Text: Use app's default dimensions
      let textW = TEXT_DEFAULT_WIDTH;
      let textH = TEXT_DEFAULT_HEIGHT;
      // Apply app constraints: min 80x40, max 80% width / 60% height of container
      const textMaxW = W * 0.8;
      const textMaxH = H * 0.6;
      textW = Math.max(TEXT_MIN_WIDTH, Math.min(textMaxW, textW));
      textH = Math.max(TEXT_MIN_HEIGHT, Math.min(textMaxH, textH));

      // Update current sizes
      currentPhotoSize = photoSize;
      currentTextWidth = textW;
      currentTextHeight = textH;

      photoBox.style.width = photoSize + 'px';
      photoBox.style.height = photoSize + 'px';
      textBox.style.width = textW + 'px';
      textBox.style.height = textH + 'px';

      // Position photo in bottom-right (matching app's default position)
      const padding = 10;
      photoBox.style.left = Math.max(padding, Math.round(W - photoSize - padding)) + 'px';
      photoBox.style.top = Math.max(padding, Math.round(H - photoSize - padding)) + 'px';

      // Position text in bottom-left (matching app's default position)
      textBox.style.left = padding + 'px';
      textBox.style.top = Math.max(padding, Math.round(H - textH - padding)) + 'px';

      console.log(`üìç Boxes positioned on reference canvas ${W}x${H}: Photo at bottom-right, Text at bottom-left`);
    }

    function clamp(n, min, max) { return Math.max(min, Math.min(max, n)); }

    function makeDraggable(el, isCropBox = false) {
      let dragging = false;
      let offsetX = 0, offsetY = 0;
      el.addEventListener('pointerdown', (e) => {
        if (e.target.classList.contains('resize-handle')) return; // Don't drag when resizing
        dragging = true; el.setPointerCapture(e.pointerId);
        const r = el.getBoundingClientRect();
        offsetX = e.clientX - r.left; offsetY = e.clientY - r.top;
      });
      el.addEventListener('pointerup', (e) => {
        dragging = false; el.releasePointerCapture(e.pointerId);
        updateOutputs();
        if (isCropBox) updateCropOutputs();
      });
      el.addEventListener('pointercancel', () => { dragging = false; });
      el.addEventListener('pointermove', (e) => {
        if (!dragging) return;
        const canvasR = editorCanvas.getBoundingClientRect();
        const w = el.getBoundingClientRect().width;
        const h = el.getBoundingClientRect().height;
        let x = e.clientX - canvasR.left - offsetX;
        let y = e.clientY - canvasR.top - offsetY;
        x = clamp(Math.round(x), 0, Math.round(canvasR.width - w));
        y = clamp(Math.round(y), 0, Math.round(canvasR.height - h));
        el.style.left = x + 'px';
        el.style.top = y + 'px';
        updateOutputs();
        if (isCropBox) updateCropOutputs();
      });
    }

    function updateOutputs() {
      const p = photoBox.getBoundingClientRect();
      const t = textBox.getBoundingClientRect();
      const c = editorCanvas.getBoundingClientRect();
      const px = Math.round(p.left - c.left), py = Math.round(p.top - c.top);
      const tx = Math.round(t.left - c.left), ty = Math.round(t.top - c.top);
      const pw = Math.round(p.width), ph = Math.round(p.height);
      const tw = Math.round(t.width), th = Math.round(t.height);

      // Update position inputs (coordinates relative to fixed reference canvas)
      inputPhotoX.value = px; inputPhotoY.value = py;
      inputTextX.value = tx; inputTextY.value = ty;

      // Update size inputs
      inputPhotoW.value = pw; inputPhotoH.value = ph;
      inputTextW.value = tw; inputTextH.value = th;

      // Always set reference dimensions so app can scale correctly
      document.getElementById('reference_w').value = REFERENCE_WIDTH;
      document.getElementById('reference_h').value = REFERENCE_HEIGHT;

      // Update display
      photoPosEl.textContent = `(${px}, ${py})`;
      photoSizeEl.textContent = `[${pw}x${ph}]`;
      textPosEl.textContent = `(${tx}, ${ty})`;
      textSizeEl.textContent = `[${tw}x${th}]`;
    }

    resetBtn.addEventListener('click', (e) => { e.preventDefault(); centerBoxes(); updateOutputs(); });
    window.addEventListener('resize', () => { if (editorWrap.style.display !== 'none') { centerBoxes(); updateOutputs(); } });

    makeDraggable(photoBox);
    makeDraggable(textBox);
    makeDraggable(cropBox, true); // true = also update crop outputs

    // Crop box toggle
    enableCropCheckbox.addEventListener('change', () => {
      if (enableCropCheckbox.checked) {
        cropBox.style.display = 'block';
        initCropBox();
        updateCropOutputs();
      } else {
        cropBox.style.display = 'none';
        clearCropInputs();
      }
    });

    function initCropBox() {
      const canvasR = editorCanvas.getBoundingClientRect();
      // Default crop box: 9:16 aspect ratio, centered
      const aspectRatio = 9 / 16;
      let cropH = Math.round(canvasR.height * 0.8);
      let cropW = Math.round(cropH * aspectRatio);
      if (cropW > canvasR.width * 0.9) {
        cropW = Math.round(canvasR.width * 0.9);
        cropH = Math.round(cropW / aspectRatio);
      }
      cropBox.style.width = cropW + 'px';
      cropBox.style.height = cropH + 'px';
      cropBox.style.left = Math.round((canvasR.width - cropW) / 2) + 'px';
      cropBox.style.top = Math.round((canvasR.height - cropH) / 2) + 'px';
    }

    function updateCropOutputs() {
      if (!enableCropCheckbox.checked) return;
      const c = editorCanvas.getBoundingClientRect();
      const crop = cropBox.getBoundingClientRect();
      const cx = Math.round(crop.left - c.left);
      const cy = Math.round(crop.top - c.top);
      const cw = Math.round(crop.width);
      const ch = Math.round(crop.height);
      inputCropX.value = cx;
      inputCropY.value = cy;
      inputCropW.value = cw;
      inputCropH.value = ch;
      inputPreviewW.value = Math.round(c.width);
      inputPreviewH.value = Math.round(c.height);
      cropInfo.textContent = `Crop: ${cw}x${ch} at (${cx},${cy})`;
    }

    function clearCropInputs() {
      inputCropX.value = '';
      inputCropY.value = '';
      inputCropW.value = '';
      inputCropH.value = '';
      inputPreviewW.value = '';
      inputPreviewH.value = '';
      cropInfo.textContent = '';
    }

    // Make crop box resizable (bottom-right handle)
    const resizeHandle = cropBox.querySelector('.resize-handle.br');
    let resizing = false;
    resizeHandle.addEventListener('pointerdown', (e) => {
      e.stopPropagation();
      resizing = true;
      resizeHandle.setPointerCapture(e.pointerId);
    });
    resizeHandle.addEventListener('pointerup', (e) => {
      resizing = false;
      resizeHandle.releasePointerCapture(e.pointerId);
      updateCropOutputs();
    });
    resizeHandle.addEventListener('pointermove', (e) => {
      if (!resizing) return;
      const canvasR = editorCanvas.getBoundingClientRect();
      const cropR = cropBox.getBoundingClientRect();
      const aspectRatio = 9 / 16;
      // Calculate new width based on mouse position
      let newW = e.clientX - cropR.left;
      newW = Math.max(50, Math.min(newW, canvasR.width - (cropR.left - canvasR.left)));
      let newH = Math.round(newW / aspectRatio);
      // Constrain height to canvas
      if (cropR.top - canvasR.top + newH > canvasR.height) {
        newH = canvasR.height - (cropR.top - canvasR.top);
        newW = Math.round(newH * aspectRatio);
      }
      cropBox.style.width = newW + 'px';
      cropBox.style.height = newH + 'px';
      updateCropOutputs();
    });

    // ============================================
    // PHOTO BOX RESIZE - Matching App Constraints
    // Photo is square (1:1 aspect ratio), min 60px, max 200px
    // ============================================
    const photoResizeHandle = photoBox.querySelector('.resize-handle.br');
    let photoResizing = false;
    let photoResizeStart = { size: 0, x: 0, y: 0 };

    photoResizeHandle.addEventListener('pointerdown', (e) => {
      e.stopPropagation();
      photoResizing = true;
      photoResizeHandle.setPointerCapture(e.pointerId);
      const r = photoBox.getBoundingClientRect();
      photoResizeStart = { size: r.width, x: e.clientX, y: e.clientY };
    });

    photoResizeHandle.addEventListener('pointerup', (e) => {
      photoResizing = false;
      photoResizeHandle.releasePointerCapture(e.pointerId);
      updateOutputs();
    });

    photoResizeHandle.addEventListener('pointermove', (e) => {
      if (!photoResizing) return;
      const canvasR = editorCanvas.getBoundingClientRect();
      const boxR = photoBox.getBoundingClientRect();

      // Calculate delta (average of dx and dy for square resize)
      const dx = e.clientX - photoResizeStart.x;
      const dy = e.clientY - photoResizeStart.y;
      const delta = (dx + dy) / 2;

      // Calculate new size with app constraints
      let newSize = photoResizeStart.size + delta;
      newSize = Math.max(PHOTO_MIN_SIZE, Math.min(PHOTO_MAX_SIZE, newSize));

      // Ensure box stays within canvas
      const maxAllowedSize = Math.min(
        canvasR.width - (boxR.left - canvasR.left),
        canvasR.height - (boxR.top - canvasR.top)
      );
      newSize = Math.min(newSize, maxAllowedSize);
      newSize = Math.max(PHOTO_MIN_SIZE, newSize);

      currentPhotoSize = newSize;
      photoBox.style.width = newSize + 'px';
      photoBox.style.height = newSize + 'px';
      updateOutputs();
    });

    // ============================================
    // TEXT BOX RESIZE - Matching App Constraints
    // Text has independent width/height, min 80x40, max 80%x60% of container
    // ============================================
    const textResizeHandle = textBox.querySelector('.resize-handle.br');
    let textResizing = false;
    let textResizeStart = { width: 0, height: 0, x: 0, y: 0 };

    textResizeHandle.addEventListener('pointerdown', (e) => {
      e.stopPropagation();
      textResizing = true;
      textResizeHandle.setPointerCapture(e.pointerId);
      const r = textBox.getBoundingClientRect();
      textResizeStart = { width: r.width, height: r.height, x: e.clientX, y: e.clientY };
    });

    textResizeHandle.addEventListener('pointerup', (e) => {
      textResizing = false;
      textResizeHandle.releasePointerCapture(e.pointerId);
      updateOutputs();
    });

    textResizeHandle.addEventListener('pointermove', (e) => {
      if (!textResizing) return;
      const canvasR = editorCanvas.getBoundingClientRect();
      const boxR = textBox.getBoundingClientRect();

      // Calculate new dimensions
      const dx = e.clientX - textResizeStart.x;
      const dy = e.clientY - textResizeStart.y;

      // App constraints: min 80x40, max 80% width / 60% height
      const textMaxW = canvasR.width * 0.8;
      const textMaxH = canvasR.height * 0.6;

      let newW = textResizeStart.width + dx;
      let newH = textResizeStart.height + dy;

      // Apply app min/max constraints
      newW = Math.max(TEXT_MIN_WIDTH, Math.min(textMaxW, newW));
      newH = Math.max(TEXT_MIN_HEIGHT, Math.min(textMaxH, newH));

      // Ensure box stays within canvas
      const maxAllowedW = canvasR.width - (boxR.left - canvasR.left);
      const maxAllowedH = canvasR.height - (boxR.top - canvasR.top);
      newW = Math.min(newW, maxAllowedW);
      newH = Math.min(newH, maxAllowedH);

      // Re-apply minimums after canvas constraint
      newW = Math.max(TEXT_MIN_WIDTH, newW);
      newH = Math.max(TEXT_MIN_HEIGHT, newH);

      currentTextWidth = newW;
      currentTextHeight = newH;
      textBox.style.width = newW + 'px';
      textBox.style.height = newH + 'px';
      updateOutputs();
    });

    singleForm.addEventListener('submit', async (e) => {
      e.preventDefault();
      singleOut.textContent = '';
      const file = fileInput.files[0];
      if (!file) { singleOut.textContent = 'Choose a file.'; return; }
      const sub = subSelect.value.trim();
      if (!sub) { singleOut.textContent = 'Select or add a subcategory.'; return; }
      const kind = detectType(file).kind;
      if (kind === 'unknown') { singleOut.textContent = 'Unsupported file type.'; return; }

      const fd = new FormData();
      const main = (mainSelect.value || '').trim();
      // Include crop coordinates if enabled
      const cropEnabled = enableCropCheckbox.checked;
      if (cropEnabled) {
        console.log('üìê Sending crop data:', {
          crop_x: inputCropX.value,
          crop_y: inputCropY.value,
          crop_w: inputCropW.value,
          crop_h: inputCropH.value,
          preview_w: inputPreviewW.value,
          preview_h: inputPreviewH.value,
        });
        fd.append('crop_x', inputCropX.value);
        fd.append('crop_y', inputCropY.value);
        fd.append('crop_w', inputCropW.value);
        fd.append('crop_h', inputCropH.value);
        fd.append('preview_w', inputPreviewW.value);
        fd.append('preview_h', inputPreviewH.value);
      }

      // Get coordinates and sizes from hidden inputs (set by visual editor)
      const px = inputPhotoX.value;
      const py = inputPhotoY.value;
      const tx = inputTextX.value;
      const ty = inputTextY.value;
      const pw = inputPhotoW.value;
      const ph = inputPhotoH.value;
      const tw = inputTextW.value;
      const th = inputTextH.value;
      const refW = document.getElementById('reference_w').value;
      const refH = document.getElementById('reference_h').value;

      if (kind === 'image') {
        fd.append('image', file);
        fd.append('subcategory', sub);
        if (main) fd.append('religion', main); // image API expects 'religion' for main
        // include coordinates (relative to fixed reference canvas)
        if (px !== '') fd.append('photo_x', px);
        if (py !== '') fd.append('photo_y', py);
        if (tx !== '') fd.append('text_x', tx);
        if (ty !== '') fd.append('text_y', ty);
        // include sizes
        if (pw !== '') fd.append('photo_w', pw);
        if (ph !== '') fd.append('photo_h', ph);
        if (tw !== '') fd.append('text_w', tw);
        if (th !== '') fd.append('text_h', th);
        // include reference dimensions for pixel-perfect app scaling
        fd.append('reference_w', refW || REFERENCE_WIDTH);
        fd.append('reference_h', refH || REFERENCE_HEIGHT);
      } else {
        fd.append('video', file);
        fd.append('subcategory', sub);
        if (main) fd.append('main_category', main); // video API expects 'main_category'
        // include coordinates for videos too
        if (px !== '') fd.append('photo_x', px);
        if (py !== '') fd.append('photo_y', py);
        if (tx !== '') fd.append('text_x', tx);
        if (ty !== '') fd.append('text_y', ty);
        // include sizes for videos too
        if (pw !== '') fd.append('photo_w', pw);
        if (ph !== '') fd.append('photo_h', ph);
        if (tw !== '') fd.append('text_w', tw);
        if (th !== '') fd.append('text_h', th);
        // include reference dimensions for pixel-perfect app scaling
        fd.append('reference_w', refW || REFERENCE_WIDTH);
        fd.append('reference_h', refH || REFERENCE_HEIGHT);
      }

      const url = kind === 'image' ? apiUrl('/api/templates/upload') : apiUrl('/api/videos/upload');
      singleSubmit.disabled = true; singleSubmit.textContent = 'Uploading...';
      updateDecisionNote();
      try {
        const res = await fetch(url, { method: 'POST', body: fd });
        const data = await res.json().catch(() => ({}));
        if (!res.ok || data.success === false) throw new Error(data.error || ('HTTP ' + res.status));
        singleOut.textContent = JSON.stringify(data, null, 2);
      } catch (err) {
        singleOut.textContent = 'Error: ' + (err.message || String(err));
      } finally {
        singleSubmit.disabled = false; singleSubmit.textContent = 'Upload';
      }
    });

    // Initial load
    fetchAllTemplatesDistinct().catch(err => console.error('Failed to load categories', err));
  </script>
</body>
</html>
